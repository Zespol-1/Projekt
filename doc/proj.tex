	\documentclass[]{article}
\usepackage[T1]{fontenc}
\usepackage{amsfonts}

%opening
\title{Projekt Zespołowy \\
	Etap projektu – projektowanie rozwiązania na zadaną architekturę}
\author{}
\date{}

\begin{document}

\maketitle

\begin{abstract}

Poniższe sprawozdanie jest wynikiem naszej pracy na drugim etapie projektu zespołowego z implementacji metody indeksu w architekturach GPU. Przedstawimy w nim przygotowane przez nas projekty i rysunki koncepcyjne wymaganych do zaimplementowania algorytmów.



\end{abstract}

\section{Analiza możliwości implementacji algorytmów mnożenia modularnego dużych liczb}
Zaproponowanym przez nas algorytmem jest ten odkryty przez rosyjskiego matematyka Anatolija Karacubę. Umożliwia on zmniejszenie złożoności czasowej ($\Theta(n^{log_{2}3})$) w porównaniu do mnożenia klasycznego ($\Theta(n^2)$) .
\newline\newline
~Projekt algorytmu:\newline

Mnożone są dwie \textit{n}-cyfrowe liczby \textit{x} i \textit{y} przy podstawie \textit{B}, gdzie \textit{n = 2m}. Przetwarzane \textit{n} może być nieparzyste, a \textit{x} i \textit{y} mogą mieć różną liczbę cyfr. W takim przypadku po lewej stronie tych liczb należy dopisać zera. Wartości \textit{x}~i~\textit{y}~należy rozpisać jako:\newline
$$ x = x_{1}B^{m} + x_2 $$
$$ y = y_{1}B^{m} + y_2, $$
gdzie $x_2$, $y_2$ < $B^m$. \newline
Przemnożenie tych liczb prowadzi do otrzymania równania:
$$xy = (x_{1}B^{m} + x_2)(y_1B^m + y_2) = x_1y_1B^{2m} + (x_1y_2 + x_2y_1)B^m + x_2y_2.$$ 
Klasycznie problem ten rozwiązuje się poprzez przemnożenie czterech czynników osobno, wykonanie przesunięcia i dodanie ich, co powoduje, że opisany algorytm wykonuje się w czasie $\textit{O}(n^{2})$. Karacuba zaproponował, by zastąpić go trzema mnożeniami:
$$X = x_1y_1$$
$$Y = x_2y_2$$
$$Z = (x_1 + x_2)(y_1 + y_2) - X - Y$$
W wyniku tego otrzymuje się równanie:
$$ Z = (x_1y_1 + x_1y_2 + x_2y_1 + x_2y_2) - x_1y_1 - x_2y_2 = x_1y_2 + x_2y_1).$$
Zatem $xy = XB^{2m} + Y + ZB^m$. Tak więc wystarczy zaledwie kilka dodatwowych dodawań i odejmowań, by zmniejszyć liczbę mnożeń z czterech do trzech.\newline
Algorytm można rozszerzyć i wykonać każde z tych mnożeń \textit{m}-cyfrowych liczb ponownie w ten sam sposób przy wykorzystaniu rekurencji.


\section{Analiza możliwości implementacji algorytmu poszukiwania relacji (oraz faktoryzacji w bazie), dla algorytmu metody indeksu}

Wstęp do wykorzystywanego algorytmu:
1. Wyznaczamy wszystkie liczby pierwsze mniejsze od \textit{B}, które tworzą bazę rozkładu.
2. Losujemy \textit{l} liczb $a_i$, gdzie $i=\overline{1,l}$, takich że rozkładają się one w wyznaczonej wcześniej bazie rozkładu.
3. Dzielimy liczby $a_i$, gdzie $i=\overline{1,l}$ przez kolejne liczby z bazy rozkładu dopóki wynik dzielenia jest całkowitoliczbowy.\newline


\section{Analiza możliwości implementacji algorytmu eliminacji Gaussa nad ciałem $\mathbb{F}_p$, dla ciał o dowolnym rozmiarze}~

\section{Metoda indeksu}~




\end{document}
